Discovery is an invaluable process contributing to the success of any software project. During the initial phase of project planning several key actors will participate in outlining a solution. I have decided to look into the role of the lead developer in this process. Working primarily from the industry standard on software project management, The Mythical Man-Month by Fred Brooks, I have come to an opinion on the role of a lead developer in the initial phases of software development. A lead developer ought to play a supportive role to the Solutions Architect, after confidently understanding the problems they’re trying to solve, they will provide a resource of experience and coarse estimation; they should not directly influence the architecture decisions of the application. The lead developer will, primarily, leave the high level planning workload to the architect, interfering as little as possible. 

A well formed project plan benefits everyone involved. The cost of planning will yield returns of improved quality and project pacing to the client. Developers may certainly have the skills and experience of planning and architecting a project, however, asking a developer to mentally manage both the planning and implementation is a consequential burden. Clearly defined tasks, with well formed definitions of “done,” are not only more easily consumed by developers, they will be more rewarding. This can seem to cause a sort of task momentum, both maintaining project pace, and higher developer satisfaction. Reducing the assumptions a developer needs to make will result in a product more aligned with client expectations. 

According to Brooks every project has a non-zero chance of slippage or failure. Risk is an unavoidable part of software projects. While it does have a fairly well studied statistical distribution, unfortunately, it is impossible to know which project will be a Black Swan1. One way to mitigate risk is maintaining team focus on scope and progress with clear iterative tasks and milestones. Knowing when a project is at risk is impossible without metrics, and metrics are impossible without a reference. The well formed discovery output is this reference standard. 

Maintaining an accurate budget for a project isn’t just an issue at fjorge, but also an industry wide issue. Poorly conceived projects with ill-defined scope are pervasive. They result in catastrophic failures of budget with quadratic overages. Just like risk of failure, risks of budget are best mitigated with well defined scope and milestones. They are also managed with anticipation of overages. Padding estimates to amortize overages isn’t cheating, it’s being honest with the realities of software development. 

With dedicated careful thought towards architecture, a complex system can be made simple. Time devoted to breaking systems down into atomic services can render a simple solution to a complex system. This simplification and compartmentalization allows the lead developer to delegate tasks to their team. These parallelized tasks can be developed independently, increasing project pace, and as a side effect, these independant loosely coupled services are more extensible and modular. If a system is developed ad hoc, without the discovery process, integration can often be more tightly coupled, and at each stage developed with myopic immediate goals. Tightly coupled projects will be harder to correct off track issues, and are less agile when features or project goals change. 
In order to produce a quality output, an architect will enlist the help of a lead developer. It is crucial that the lead developer understand the problem they are being tasked with assisting.  The lead developer will need to be able to reiterate the problem before they earn confidence in their suggested implementation. Developing a full understanding of the problem, and then communicating fully what the problem is, will prove they have the deep grasp needed to develop a solution. Once a lead developer has this understanding the solution will develop almost organically.

A lead developer will provide, to the best of their ability, accurate but not necessarily precise estimates regarding the timeline for any specific implementation. The solutions architect should consider the developers tendency to favor the median time of implementation and not the mean time.2 Developers are also notoriously overconfident in implementation time frames. Developers will optimistically estimate tasks they already know; they are poor estimators for tasks they do not know, and they’re especially bad at estimating tasks they don’t realize they don’t understand. A source of disparity in developer estimates versus actual implementation times is the developer will assume they navigate directly to the solution. This is unlikely, as the development process often includes refactoring, and learning. Developers also neglect to accommodate testing, QA and planning time. Brooks suggests that actual code development should be as little as ⅙ the project time, with planning consuming ⅓ of the project time. If a developer is estimating only optimistic code time, they’re leaving out as much as 85% of the time needed to produce a quality product. 

A lead developer must avoid bike-shedding tasks. The architect will manage the high level issues while the lead developer will work out representative tasks of features and milestones, but the actual implementation and fine details should be left to the individual developers. Scads of well formed, high accurate estimates on incidental tasks, and micro level decisions of implementation can harm the estimation. Besides burning off time that should be dedicated to difficult design decisions, they can provide a false sense of completeness. Even after all the time invested, there is no guarantee the developer will be able to utilize those decisions during development. 

The primary advantage of isolating the role of architecture from implementation estimation is the decoupling of biases. The lead developer will play an ancillary role to discovery, they are a vital source of implementation detail and pragmatic information. They can provide insights from experience in similar projects, however, since each product is different, and the lead developer is packaged with biases and ego they will only provide information that can be utilized at a high level value. 

1: https://www.investopedia.com/terms/b/blackswan.asp
2: https://erikbern.com/2019/04/15/why-software-projects-take-longer-than-you-think-a-statistical-model.html
