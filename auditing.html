Auditing an Inherited Project

Find the documentation. Start there. 
Understand what it does now. Changing a system you’re unfamiliar with is chaos. 
Understand the change. A change without an effect on features is refactoring.
Adding unit tests is as much about maintaining the legacy code features, as it is about understanding the code itself, and making the feature changes concrete. 
Be humble, and understand that “Someone elses code” isn’t really the problem.   Patterns and techniques change as much as anything. If you respect the code, it’s mostly likely you will add respectable code to it. 
Leave the code better than you found it. 
Draw a UML of what part of the code you’re working in. If you understand it’s current workflow, you will be able to modify it better.  You may have to request this time, but it will likely save hours later.  (Class diagrams, Entity Relationship Diagram, logic diagram)
Can your changes be encapsulated, and injected to add minimal changes to existing code? 
Is it useful to build a layer on top of the previous code. As a transform, or new interface?
Devise tests, this will help you understand the application, and help catch bugs. 
Is there refactoring that can be done to allow changes to be done more easily. Are scattered algorithms that can be refactored into methods, organizing the area before you code can allow feature changes to be more easily inserted. 
If there are library updates we will need to insure they will not overwrite modifications. This could have unknown side effects. 
Look for any security vulnerabilities, third party modules, suggested upgrades that can be used to provide additional future work recommendations.  
Bring the source code into some sort of version control if it’s not already. 
Document Document Document


Identify:
the patterns used in the software. (They may be out of date.)
the area of concern.
if the feature changes are isolated to a small segment of code. 
refactoring opportunities that will improve new features.
unit testing opportunities.
