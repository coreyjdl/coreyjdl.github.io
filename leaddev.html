Lead Developer Role Pre-Project
Providing Assistance to the SA
Work your way down from overall solution, to the individual components. Thoroughness at this stage pays large dividends later. 
What are the high level components of this project?
What are the separate layers and components of this project?
What are the atomic elements of this project?

“The Database” (High Level)
Sql-Server Db (Component)
DAL (layer)
Entity Framework (Component)
User Entity (Atomic) (I am on the fence about entities being atomic in general, but at this phase the specific details would be handled by UML diagrams of the database, and they serve as units in regards to method signatures.)
Order Entity (Atomic)
Class of CRUD Methods (Component)
Void SaveEntity<T>(IEntity entity) method (Atomic)
C# API (High Level)
Order Controller (component)
IEnumerable<Order> GetCustomerOrders(string UserGUID) (atomic)
Order ViewModel (component)
double CalculateTotalShipping(Order order) (atomic)
Angular Frontend (High Level)
Cool new idea that makes this project unique packaged as a Service.  (High Level)
ICoolService interface (Component)
int CoolMethod(CoolObject object); (atomic)


With this fully developed out the application is essentially “built.” A developer would only need to implement what is needed to match the signature of the methods, and the other goals of any components and layers.

Can you clearly reiterate the problem each tier of the product is trying to solve, showing  they’re well understood, working your way down from the high level to the atomic solutions? It’s nearly impossible to solve any issues without actually understanding the problem.

Task: “Create Database for application”
What is this task solving?  “There is no existing database for this site, it needs a database to store the users, their orders, and all of the products.”

“There is no existing database” yields the simple task of “create an empty database named application_db”.
“To store Users” yields the sub task of “create a user record.”

Task: “Create a user record in the database”:
What is this task solving:  “Providing a place to store users id, name and address”
Answering this task fully yields the structure of the table.  “id | name | address”

Task: “ create method to calculate the total shipping of an order”
What is this task solving? “The display field on the orders view needs a dollar value that is the total of an order based on the quantity and price of products in that order”

“Needs a dollar value” says to me the return type should be a double,
“Of an order” says that this might be best as a method of that order object.
This can almost yield my methods signature:
public, since I determined something else needs it. 
double, since it’s a dollar value, and this is a general best practice for that. 
CalulateTotalShipping(), since that’s a clear description of what I want this method to do, and there’s no outside influence needed in the form of parameters. 
public double CalculateTotalShipping();
 
Is this project similar to something we’ve done? How long did that project actually take?

Project X was an Angular C# project and it took 800 hours, it doesn’t have that cool service, but that should mostly cover the UI. 
CoolService is a lot like MediocreService, that whole project took 600 hours, but it had a UI layer that normally only takes 200 hours. 
Therefore 800 + 600 - 200 should be a fair guess. 

Do your estimates include Planning, Development (Coding), Testing, Documentation and QA times? Actual development time is often the smallest component. 
	
The goal here is to get yourself out of the mindset of estimating the raw task, which is never really the majority of time used. Writing well defined single responsibility method shouldn’t take very long.. It’s the ancillary task of mocking the environment to test it, refractor it, and QA it that take the majority of time. 
Confirming the SA Deliverables are Adequate
Are the design patterns and structure of the application clear, are they reasonable? Now is the time to enforce design best practices.

Here you would analyze the structure and connectivity of the project infrastructure. Are the services well developed, but don’t have a defined home within the application? Are there appropriate interfaces to connect these components? 
As far as design patterns, can these pieces of the application be communicated in terms of how they’ll work with the other pieces, is the layer of the application clear that it’s an ‘Adaptor’ for an SDK, or a Factory for user objects. Think of any hypothetical feature changes or additions of a service, where would it go, how well would it implement in the infrastructure you have built?  Are components too tightly coupled to allow a new feature to exist without affecting multiple parts of the application.

Are the services and components well defined as discrete components of the application? Encapsulating workloads into components will improve scalability, and maintainability.

Do the pieces of the application stay in their own lane? Is it the application loosely coupled so that swapping services, and augmenting portions of the site remains easy? If this is well structured the site will be more agile. Changes will fit neatly back into the application and creep won’t be as detrimental to timelines. 

Are there tasks and is there time given to connecting services and application layers together. This is an often overlooked part of the process.

This concept won’t be present in the architecture, this is where the tasks estimated fill in the voids of actually wiring up the site. Technically with best practices, like using interfaces and other ways to agree on signatures of methods between services, this would actually not be an issue. The developer creating the client would code to the signature of the method in the service, test using a mocked version and when merged along with the service it would work as expected. 

What libraries are needed, and will there be time required for developers to learn these? 
	
Greenfield projects will most certainly bring in new tech, or hyper specific libraries for the project. It’s very likely that there will be time taken to learn, if not by all developers, at least a few, this should be accounted for in general with in the estimates. If the timing is too tight, the lead developer needs to rely on their experience and knowledge of their team to push back for a reasonable amount of learning time.

Do you understand why the architect selected the technologies they chose? Do you think they’re suitable? Have them explain why they chose those tools if you have doubts. 

This is where your experience is specifically helpful. Ideally you would be involved from the beginning on selecting technologies, but if an unexpected framework makes it way to them after the fact, you need to analyze if this is a “new for the sake of new” solution, or if it’s a solution that a technology the team is already familiar with could solve quicker.

Can most tasks be started and completed independently of other tasks? Ideally services will be discrete enough they can all be assigned at any time, to any dev and completed independent of the other components.

With best practices and clear architecture design each component of the application should be able to come together independently. If there are six components, and your team had six developers, in theory the project should come together almost wholly after each developer is done with their scope of the project.

For each part of the application, can you imagine the implementation, is it complex enough to split into more tasks? Your imagined implementation does not need to be identical to the final solution, but if you cannot mock an implementation there may be gaps in understanding of the problem, or the task may not be singular enough. 

Without giving some sort of metric for what makes an atomic task, you should be able to suss out a task that is hiding multiple tasks. Tasks should be single actions, single methods. If it’s unclear that it’s atomic, imagine the implementation, write some pseudocode, if the task contains multiple concerns break it down. 

Are there any epics that seem under architected, or vague as far as design or the solution? Push back if there are neglected layers.

During development you should have the autonomy to split tasks as needed and fill out some voids, however, if a large portion of the application seems under developed in concept, perhaps at some stage requirements were unclear. Push back, it may be an issue all the way back to the client not fully understanding what they need from the application.

Are the components singular in overall responsibility? If not, can they be broken down? We want tasks and components as granular as we can be. (Don’t bikeshed the details, but keep in mind a singular responsibility paradigm)

Follow S.O.L.I.D principles for everyone's sanity. The resultant architecture should be within that framework. Keeping things granular and focused will allow feature changes by the client to fit in easier, and provide a more maintainable and scalable product. It will also help in delegating, and defining milestones. 

Is there a plan for testing development? TDD? At this point there should be time estimated to include building unit tests.

We should be building tests, demand time for them. Testing frameworks are a technology, and should be decided on in this phase or before. 

Is the design accommodating of scaling? It should be modular enough if designed well, scaling should be no problem. 

If you’ve answered affirmative to the SOLID principles questions we should be good to go by now, however, keep in mind factors like hosting environment or even the power of the frameworks chosen.

Does the design allow maintainability? If components maintain a single responsibility, and services are properly encapsulated, feature growth and maintainability should follow easily. 

If you’ve answered affirmative to the SOLID principles questions we should be good to go by now, however, keep in mind factors like hosting environment, vendor buying, or even the power of the frameworks chosen.

Taking Ownership of the Project
What epics can be done at the same time, which ones need to be done sequentially? Ideally all of them can be done at any time, however, wrap up and implementation will need to be done after most of the components are completed. Delegate to the developers the entirety of a major component, try not to mix and match component tasks, each developer should have their own small program to complete, that will later be merged into a product. 

Not to beat a dead horse about it, but a well designed app should be almost completely parallelizable on the component level, this is not always the case. 

Is the compartmentalization of tasks for Front End and Back End clearly defined? 

This line is hazy in general, but if pieces are encapsulated with proper epics, the team working on each part should be fairly obvious. 

What are the coding conventions for this application? Do we need to define naming conventions, design best practices etc? Enforce this as well as you can. Dealing with maintenance and feature creep will be more manageable if the entire application is consistent. 

You should be doing code reviews, with well encapsulated sections of the app and well managed version control this can be done iteratively, and regularly. Establish the conventions early, and enforce them. The client will change a feature or add requirements and consistency will help integration of these changes happen smoothly. 

Are you familiar with the expected deployment environment and timeline, and what your devs will need to begin working towards that goal? Some technologies 




Glossary:

Greenfield Project: A project lacking constraints from prior work. 

SOLID: A mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable. 
Single Responsibility
Open / Closed
Liskov Substitution
Interface Segregation
Dependency Inversion

Bikeshedding: When members of a group give disproportionate weight to trivial components. 

